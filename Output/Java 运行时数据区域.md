---
type: permanent
banner: Assets/Banner/pexels-eberhardgross-1624496.jpg
---
# 🌐 核心观点

Java Runtime 数据区域分为线程私有和线程共享的区域, 线程私有区域有程序计数器, 虚拟器堆栈, 本地方法栈, 线程共享的区域有堆和方法区.

---

# 🔖 详细解释

## 1	线程私有区域

### 1.1	程序计数器

程序计数器是一块较小的内存空间, 可以看作当前线程执行的字节码的行号指示器. 在 java 虚拟机的概念模型中, 字节码解释器工作就是通过改变程序计数器的值来指定下一个要执行的代码, 由此来实现分支, 循环, 跳转, 异常处理, 线程恢复等等基础功能.

如果线程执行的是一个 Java 方法, 那此时程序计数器指向的就是正在执行的虚拟机字节码地址, 如果执行的是本地 Native 方法, 那么这个计数器的值为 Null.

程序计数器是 Java 虚拟机规范中唯一没有规定任何 OutOfMemoryError 的区域.

### 1.2	虚拟机堆栈

虚拟机堆栈是以线程为单位的一块内存, 它的生命周期与线程的生命周期相同;每个方法被执行的时候, JVM 会同步创建一个栈帧 (Stack Frame), 用于存储局部变量表, 操作数栈, 动态连接, 方法出口信息.

![[Java 虚拟机栈帧存储的信息.png|800]]

Java 中所有的传参都是值传递, 基本类型传递的是值本身, 引用类型传递的是引用地址的值, 这些值就是存储在局部变量表的.

### 1.3	本地方法栈

本地方法栈专门用于支持 Native 方法, 这些方法通过 Java Native Interface (JNI) 调用. JNI 允许 Java 代码与本地代码进行交互, 以实现一些平台相关的功能或优化性能.

- **存储本地方法调用信息**: 本地方法栈保存每个线程调用的本地方法的相关信息, 包括本地变量, 输入参数, 返回值等.
	
- **线程私有**: 本地方法栈和 Java 栈一样, 每个线程都有一个独立的本地方法栈. 一个线程调用本地方法时, 其调用信息会被压入其本地方法栈中.
	 
- **动态调整**: 栈的大小可以在 JVM 启动时指定, 通常 JVM 实现会动态调整本地方法栈的大小以适应不同的需求.

## 2	线程共享区域

### 2.1	堆区

在 JVM 启动的时候创建, 是虚拟机所管理的最大的一块内存, 被所有线程所**共享**; 堆内存区域存在的唯一目的就是**存放对象实例**, Java 中所有的对象实例都在这里分配内存, 内存被垃圾收集器管理.堆区域一般会被划分为**年轻代和老年代**, 根据对象年龄来决定其存放位置.

年轻代是 Java 堆内存中存储新创建对象的区域. 年轻代通常进一步划分为三个子区域:

- Eden 区:所有新对象首先分配在 Eden 区. 当 Eden 区满时, 会触发一次年轻代垃圾收集, 这些对象要么被移动到 Survivor 区, 要么被清除.
	
- Survivor 区(S0 和 S1): Survivor 区用于保存 从 Eden 区复制过来并且在垃圾收集中存活的对象.

在每次垃圾收集后, Eden 区存活的对象会被复制到其中一个 Survivor 区. 在后续的垃圾收集中, 如果对象再次存活, 它们会被复制到**另一个** Survivor 区. 这个过程**反复进行**, 直到对象被晋升到老年代.

老年代是存储长生命周期对象的区域. 对象在年轻代经过多次垃圾收集后, 如果仍然存活, 会被晋升到老年代.

- 老年代的垃圾收集称为老年代垃圾收集, 这个过程通常比年轻代垃圾收集更**耗时**, 因为老年代中的对象存活时间更长且数量更多.
	
- 老年代占用更大的空间, 因为经过大量的数据分析发现, 大部分的对象都是朝生夕死的, 每次回收可以清理出大量的年轻代内存空间, 而老年代存储的对象不易消亡.

### 2.2	方法区

方法区用于存储静态元素, 当 JVM 加载一个类时, 首先会读取 Class 文件中的**常量池信息**, 并将其**复制到运行时常量池**中. 当程序运行时, 可以从运行时常量池中获取需要的常量. 方法区中存储的内容有:

- **类信息**: 类和接口的结构信息, 包括类名, 父类名, 接口名, 修饰符, 常量池等.
	
- **字段信息**: 包括字段名, 类型, 修饰符等.
	
- **方法信息**: 包括方法名, 返回类型, 参数类型, 修饰符等.
	
- **运行时常量池**: 存储编译期生成的各种字面量(如字符串常量)以及符号引用(如类和方法的引用). 这些常量在类加载时被解析, 并在运行时使用.
	
- **方法的字节码**: 存储每个方法的字节码指令, 供 JVM 执行.
	
- **静态变量**: 存储类的静态字段, 这些字段在类加载时被分配内存.
	
- **JIT 编译后的代码**: 如果使用了即时编译器, 那么 JIT 编译后的本地机器码也会存储在方法区中.