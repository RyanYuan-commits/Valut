---
type: permanent
---
# 🌐 核心观点

JSR-310 (Java Time API) 的设计彻底抛弃了 java.util.Date 的可变对象模型, 转而采用**不可变值对象**(Immutable Value Objects)模式. 这意味着一旦一个时间对象被创建, 它的状态 (年, 月, 日, 秒等) 就**永远无法被修改**.

---

# 🔖 详细解释

## 1	可变性是 "万恶之源"

在旧的 `java.util.Date` 时代, 以下代码会产生严重的生产事故:

```java
// 假设这是一个全局共享的截止日期
Date deadline = getSharedDeadline(); 

// 程序员 A 只是想计算明天的日期进行逻辑判断
deadline.setDate(deadline.getDate() + 1); 

// 结果: 所有引用该 deadline 的地方，时间全都悄悄变了！
```

导致了难以排查的 Bug, 尤其是在多线程的环境下, 必须通过大量的同步语句来保护数据.

## 2	JSR-310 的实现机制

`java.time` 包下的核心类 (如 `LocalDate`, `Instant`, `ZonedDateTime`) 通过以下手段确保不可变性:

- **类定义为 final**: 防止通过**继承**来破坏行为.
	
- **字段私有且 final**: 底层存储 (如 seconds, nanos) **在初始化后不可更改**.
	
- **修改即创建**(Copy-on-Write): 所有的修改操作 (如 plusDays, withHour) 都不会修改原对象, 而是**返回一个全新的实例**.

## 3	带来的技术红利

**天然线程安全**: 多个线程可以同时读取同一个 LocalDateTime 实例, 无需任何同步锁. 这极大地提升了高并发下的性能.

**函数式编程友好**: 由于没有副作用, 它可以完美配合 Java 8 的 Stream 和 Lambda.

**缓存友好**: 常用的时间对象 (如 LocalTime.MIDNIGHT) 可以被安全地定义为静态常量并反复复用.

---

# 📚 参考内容

[JSR-310 Date and Time API Guide](https://jcp.org/aboutJava/communityprocess/pfd/jsr310/JSR-310-guide.html)
