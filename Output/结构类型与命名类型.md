---
type: permanent
---
# 🌐 核心观点

类型系统是编程语言设计的核心部分, 通常为语言提供基础. 设类型系统的关键是决定类型之间的关系.

---

# 🔖 详细解释

在任何系统中, 类型 A 和 B 有三种可能的关系:

- A 是 B 的子类型;
	
- A 是 B 的超类型;
	
- A 既不是 B 的子类型也不是超类型.

 类型关系在理解类型兼容性方面很重要, 如果两个类型在特定上下文中可以互换而不会导致类型错误, 那么它们就是兼容的.

## 1	名义类型系统

类型关系必须通过显示的声明来建立, 比如通过 extends 或 implements 关键字.

典型的语言有: Java, C++, Swift, Kotlin.

```php
<?php
//NOMINAL
 
interface Animal {
    function eat(): void;
}
 
// Dog is a subtype of Animal
// as it is explicitly declared
interface Dog extends Animal {
    function bark(): void;
}
```

## 2	结构类型系统

类型的兼容性由类型的实际结构或成员来决定, 只要两个拥有相同名称和类型的成员 (方法, 字段), 它们就被认为是兼容的, 无需任何显示的声明.

典型语言有: TypeScript, Go, Rust.

```php
// STRUCTURAL
 
interface Animal {
    eat(): void;
}
 
// Dog is a subtype of Animal
// as all of Animal's members are present
interface Dog {
    eat(): void;
    bark(): void;
}
```

## 3	对比总结

### 3.1	名义类型的优势与劣势

优势:

- 清晰明确: 代码中类型之间的关系一目了然.
	
- 早期错误检测: 由于需要显式声明, 很多错误在编译初期就能发现.
	
- 性能: 编译器在编译时就能确定方法调用地址(虚方法表), 运行时开销小.

劣势:

- 缺乏灵活性: 著名的“表达式问题”--难以让已存在的类型实现新的接口而不修改其源码.
	
- 样板代码多: 需要编写大量的 implements 和 extends 声明.

### 3.2	结构类型的优势与劣势

优势:

- 极高的灵活性: 支持鸭子类型, 非常适合泛型编程和与动态语言互操作.
	
- 代码简洁:减少了声明依赖的样板代码.
	
- 强大的泛型能力: 可以编写更通用, 约束更灵活的泛型代码.

劣势:

- 偶发兼容性: 有时两个无关的类型可能因为偶然拥有相同的结构而被误认为兼容, 可能导致微妙的 bug.
	
- 重构风险: 重命名一个接口中的方法可能会意外地破坏大量看似无关的, 但结构上匹配该接口的类型. 在名义系统中, 只有显式声明的类型会受影响.
	
- 工具支持: IDE 的跳转, 重构等功能可能不如名义系统那么精确.


---

# 📚 参考内容

