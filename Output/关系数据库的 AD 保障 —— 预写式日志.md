---
type: permanent
aliases:
  - WAL
  - Write-ahead logging
  - 预写式日志
banner: Assets/Banner/pexels-bertellifotografia-1144690.jpg
banner-x: 55
banner-y: 66
---
# 🌐 核心观点

预写式日志 (Write-ahead logging, WAL) 是关系型数据库用于保证其原子性和持久性的一系列技术.

---

# 🔖 详细解释

## 1	什么是预写式日志?

预写式日志是**关系数据库系统**用于实现**原子性**和**持久性**的一系列技术.

当修改提交之前, 数据库系统保证这些修改被写入到磁盘中的 Log 文件中, 因此, 数据库系统无需在每次提交时都执行耗时的随机写磁盘操作以保证持久性, 而可以选择缓冲批量写等更高效的方式, 当出现意料之外的服务宕机时, 可以借助 Log 文件中的记录快速的恢复, 以此来保证持久性.

Log 文件通常包含 redo 和 undo 信息, redo 用于保证持久性, 防止掉电丢失数据, undo 保证原子性, 用于回滚事务和多版本并发控制.

## 2	预写式日志的优缺点

预写式日志能够减少写磁盘的次数, 系统无需在每次提交后都写磁盘来保障持久性, 而可以去构建缓冲区来提升系统整体性能.

借助 redo log 可以实现在线备份以及时间点恢复.

但是, 对于非常大的事务, 预写式日志的性能将会降低, 在 HBase 中, WAL 写入 HDFS 需要两次网络交互, 会严重影响 HBase 的写入性能, 因此HBase采用异步WAL提交, 将日志缓冲后批量刷盘, 避免阻塞客户端. 且由于预写式日志在刷盘之前存放在相同的队列, 队列的并发性能也会对预写式日志的写性能产生影响.

## 3	预写式日志核心工作原理

### 3.1	Write-Ahead 规则

系统对数据页的任何修改, 必须先完整记录到 WAL 日志并持久化到磁盘, 在这之后数据页才允许被刷新到存储.

### 3.2	LSN 机制

Log Sequence Number, LSN, 是用于唯一标识每个日志记录/数据页状态的递增整数, 关键的 LSN 类型有:

```
0  --------|--------------------------|--------------------------|----> LSN 轴
           ↑                          ↑                          ↑
    Checkpoint LSN           当前 Redo 写入位置    Redo Log 结尾
      (1000)                   (比如 5000)         (文件末尾)
           |________________________|
                    |
            这一段区间是未刷盘的脏页
            (需要通过 Redo Log 保护)
```

Redo Log 的空间是有限的, 比如 MySQL 默认的 Redo Log 文件大小为 48 MB, 这就要求 Redo Log 必须是可复用的; 而当记录被刷新到磁盘, 这部分 Redo Log 就可以被清除来实现复用, 预写式日志中用 **Checkpoint LSN** 来记录 "有哪些日志对应的操作已被刷新到磁盘, 可以丢弃".

数据库系统与磁盘的交互是以数据页为单位的, 所以在数据页上需要记录当前数据页最近一次更新的 LSN. 

后台线程将数据页刷入到内存中,每次刷完一批脏页, 系统会检查当前还在内存中的脏页的最小 LSN 是多少, 然后将 Checkpoint LSN 置为这个 LSN.

## 4	WAL 断电恢复原理

### 4.1	读取 Checkpoint LSN

恢复的第一步并非从头扫描所有日志, 而是直接读取 Redo Log 文件中的 Checkpoint LSN. Checkpoint 记录了所有脏页已安全落盘的临界点. LSN 小于 Checkpoint 的修改必然已经在磁盘数据页上, 无需重做. 因此, 恢复扫描仅从 Checkpoint LSN 开始, 大幅缩短恢复时间.

### 4.2	扫描与重做

从 Checkpoint LSN 开始向后扫描 Redo Log, 针对每一条日志记录(如 LSN 2000), 执行“体检”逻辑:

- 读取磁盘页: 将日志对应的数据页从磁盘读入内存.
	
- 获取 Page LSN: 检查该数据页头部的 Page LSN(即该页最后一次物理更新时的 LSN).

若 Redo LSN > Page LSN: 说明日志记录的修改发生在该页最近一次刷盘之后. 这意味着断电导致该修改丢失, 必须执行 Redo(重做). 若 Redo LSN <= Page LSN: 说明该页在断电前已经包含了该次修改(甚至更新的修改), 数据已持久化. 直接 跳过, 避免重复操作.

### 4.3	事务回滚:处理未提交的事务

Redo Log 是物理日志, 重做阶段会不加区分地恢复所有已记录的修改, 包括那些执行了一半但未提交的事务. 为了满足原子性, 恢复流程随后会利用 Undo Log 进行清理;

在事务系统中查找那些在 Redo Log 中有记录但最终无 COMMIT 标记的事务, 利用 Undo Log 中记录的修改前数据, 将上述未提交事务所做的修改逆向撤销, 确保数据库状态不包含脏数据.

### 4.4	异常页处理:Doublewrite Buffer (双写缓冲)

如果在重做阶段发现磁盘上的数据页本身已损坏(如写了一半导致校验失败), Redo Log 无法基于坏页进行恢复. 此时, InnoDB 会利用 Doublewrite Buffer 中存储的该页副本进行修复, 修复后再继续应用 Redo Log.

---

# 📚 参考内容

