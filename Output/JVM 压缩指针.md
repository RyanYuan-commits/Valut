---
created: 2025-11-24
type: permanent
---
# 🌐 核心观点

JVM 通过压缩指针来压缩存储指针需要的内存, 因为 JVM 中对象通常采用 8 字节对齐的方式, 所以采用每个地址对应一个 8 字节的内存块的方式. 

---

# 🔖 详细解释

## 1 背景

在 32 位系统下运行的 JVM 中, 一个内存地址是 32 位的(4 Byte), 支持对 4GB 内存空间的寻址;

在 64 位系统下运行的 JVM 中, 一个内存地址是 64 位的(8 Byte), 它能寻址的内存空间巨大, 远超应用的需求; 但是程序中所有的引用大小都从 4 字节变为了 8 字节, 内存占用显著增加.

## 2 核心原理

JVM 中的对象在堆上分配的时候, 会进行字节对齐: 现代 JVM 中, 对象通常是 8 字节对齐的, 这意味着任何对象的起始内存都是 8 (1000) 的倍数, 也就意味着这些地址的二进制表示的最后 3 位永远是 000. 既然最后 3 位总是 0, 存储它们会造成内存的浪费, 于是 JVM 采用了以下的策略:

- **编码**: 存储对象引用的时候, 不存储完整的 64 位地址, 而是讲这个地址右移 3 位, 然后用一个 32 位的数来存储这个结果;
	
- **解码**: 读取的时候, 左移三位得到最终的地址.

32 位的数能表示的最大值为 $2^{32}$, 每个地址表示一个 8 字节的块, 总共可以寻址 32 GB 的内存. 所以, 在堆内存小于 32GB 的情况下, 压缩指针默认开启.

## 3 控制和查看压缩指针

```bash
-XX:(+/-)UseCompressedOops
```

开启或者关闭压缩指针, 在现代的 64 位 JDK 中, 当最大堆内存小于 32GB 的时候, 压缩指针默认开启.

---

# 📚 参考内容

