---
type: permanent
banner: Assets/Banner/pexels-bertellifotografia-1144690.jpg
---
# 🌐 核心观点

记录常见的 Java 字节码指令

---

# 🔖 详细解释

## 1	对象初始化指令

### 1.1	new 指令

在 Java 字节码中有一个指令叫做 new, 例如, 当创建对象时:

```java
 0: new #2 // class demo/jvm0104/HelloByteCode
 3: dup
 4: invokespecial #3 // Method "<init>":()V
```

new 指令负责分配内存与初步初始化:

- 首先检查指定的类是否被加载, 解析和初始化, 如果没有, 会先执行必要的[[Java 对象初始化过程.canvas|类加载过程]].
	
- 然后在 Java **堆**中为这个对象分配内存空间;
	
- 将**内存空间**初始化为 0 值;
	
- 将新创建的对象**压入栈顶**.

当 new, dup, invokespecial 一起出现时, 一定是在创建类的实例对象. 在调用初始化方法之前, 要通过 dup 将类的引用复制一份压入栈顶, 因为 invokespecial 会消耗掉一个栈顶的数据. 

### 1.2	深入探讨 \<init> 与 \<clinit>

在调用构造函数时, JVM 实际上执行的是名为 \<init\> 的方法. 一个类可以有多个 \<init\> 方法, 对应重载的构造函数.

\<clinit\> 即 class_init, 由编译器自动生成, 包含了所有静态字段的显示初始化和静态初始代码块中的代码, 不能被直接调用, 而是由 JVM 首次使用一个类时自动触发, 触发的时机包括: 创建实例, 读取或设置静态字段, 调用静态方法.

## 2	栈内存操作指令

最基础的是 dup 和 pop 指令, dup 用于复制栈顶的值并将其入栈, pop 指令用于弹出栈顶的值.

复杂一点的指令有 swap, dup_x1, dup_x2

- swap: 交换栈顶两个元素的值;
	
- dup_x1: 复制栈顶的值, 然后将其插入到栈的第三个位置 (跳过栈顶和次栈顶的值);
	
- dup2_x1: 将顶部的一个或两个操作数栈值复制并向下插入两个或三个位置

![[Java 字节码栈操作指令案例.png]]

## 3	局部变量表指令

stack 主要用于执行指令, 而局部变量则用来保存中间结果, 两者之间可以直接交互.

| 指令类别 | 示例                     | 功能描述          | 适用场景                  |
| ---- | ---------------------- | ------------- | --------------------- |
| 加载   | `iload_1`, `aload 5`   | 将局部变量值复制到操作数栈 | 在计算或方法调用前准备参数         |
| 存储   | `istore_2`, `astore 4` | 将操作数栈顶值存入局部变量 | 保存方法返回值或中间计算结果        |
| 优化   | `iload_0` ~ `iload_3`  | 对前 4 个变量的快速操作 | 访问 `this`、方法参数、常用局部变量 |
| 宽指令  | `wide istore 300`      | 处理大索引>255的变量  | 方法拥有大量局部变量时           |



---

# 📚 参考内容

[Java 字节码技术: 不积细流, 无以成江河](https://o.alldu.cn/docs/jvm-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-32-%E8%AE%B2%E5%AE%8C/05-java-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF%E4%B8%8D%E7%A7%AF%E7%BB%86%E6%B5%81%E6%97%A0%E4%BB%A5%E6%88%90%E6%B1%9F%E6%B2%B3/#411-%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%e6%8c%87%e4%bb%a4)