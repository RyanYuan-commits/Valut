---
source: https://baoyu.io/blog/google-prompt-engineering-whitepaper
type: input
banner: Assets/Banner/pexels-photo-9160637.jpeg
---
# 📰 阅读笔记

## 1	引言

构建最高效的提示很复杂, 受到诸多因素的制约, 提示工程是一个**迭代**的过程.

## 2	提示工程

理解 LLM 的工作原理至关重要: 它是一个**预测引擎**. 模型**接收顺序文本作为输入**, 然后**基于其训练数据**预测下一个应该出现的令牌. 

LLM 被设计为**反复执行**此过程, 将先前预测的令牌添加到序列文本的末尾, 以预测下一个令牌. 下一个令牌的预测基于**先前令牌中的内容**与 LLM **在训练期间所见内容**之间的关系.

当编写提示时, 实际上是在尝试**引导** LLM **预测正确的令牌序列**. 提示工程是设计高质量提示以引导 LLM 产生准确输出的过程. 这个过程涉及反复调试以找到最佳提示, 优化提示长度, 并评估提示的写作风格和结构与任务的关系. 在自然语言处理和 LLM 的背景下, 提示是**提供给模型的输入**, 用以**生成响应或预测**.

## 3	LLM 输出配置

### 3.1	输出长度

响应中要生成的令牌数量, 生成更多的令牌 LLM 需要进行更多的计算, 响应速度更慢, 成本更高.

减少输出长度不会让 LLM 输出的文本更加简洁, 是一个**强制截断**, 只是导致在达到限制时停止预测更多令牌, 如果需要较短的输出长度, 还需要相应的设计提示.

### 3.2	采样控制

LLM 并非真正的预测单测令牌, 而是下个令牌可能是什么的**概率**, 然后对这些令牌概率进行采样, 以确定将生成的下个令牌. 

温度, Top-K 和 Top-P 是最常见的配置, 决定了如何预测**令牌概率**以选择单个输出令牌.

#### 3.2.1	温度

控制令牌选择中的**随机程度**, 温度为 0 表示始终选择概率最高的令牌, 但不代表输出总是相同 (平局的情况).

随着温度越来越高, 所有令牌成为下一个预测令牌的可能性变得均等, 温度参数提供了一个在 可预测性/事实准确性 与 创造性/多样性 之间的权衡. 不同任务可以选择不同的温度, 即事实回答需要低温, 而故事生成需要高温.

#### 3.2.2	Top-K 和 Top-P

Top-K 和 Top-P 是 LLM 使用的两种采样设置, 用于将预测的下一个令牌限制为来自具有最高预测概率的令牌.

- Top-K 采样从模型预测的分布中选取概率最高的 K 个令牌, Top-K 的值越高, 模型的输出越具有创造性和多样性;
	
- Top-P 采样选择累计概率不超过 P 的最高概率令牌, P 的范围从 0 到 1.

#### 3.2.3	综合运用

在 Top-K, Top-P, 温度和要生成的令牌数量之间进行选择, 取决于具体的应用和期望的结果, 并且这些设置相互影响 1. 理解所选模型如何组合不同的采样设置也很重要.

如果温度, Top-K 和 Top-P 都可用(如在 Vertex Studio 中), 则同时满足 Top-K 和 Top-P 标准的令牌成为下一个预测令牌的候选者, 然后应用温度从通过 Top-K 和 Top-P 标准的令牌中进行采样. 如果只有 Top-K 或 Top-P 可用, 行为相同, 但只使用一个 Top-K 或 P 设置.

如果温度不可用, 则从满足 Top-K 和/或 Top-P 标准的令牌中随机选择一个, 以产生单个下一个预测令牌.

## 4	提示技巧

提示文本越清晰, LLM 预测下一个可能的文本的效果越好, 利用 LLM 的训练方式和工作原理的特定技术将有利于 LLM 获取相关结果.

### 4.1	通用提醒 / 零样本

零样本提示是最简单的提示类型, 仅提供任务描述和一些供 LLM 开始使用的文本, 零样本代表着 "没有示例".

| 字段           | 值                                                                                                                            |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| 名称 (Name)    | 1_1_movie_classification                                                                                                     |
| 目标 (Goal)    | 将电影评论分类为正面, 中性或负面. (Classify movie reviews as positive, neutral or negative. )                                               |
| 模型 (Model)   | gemini-pro                                                                                                                   |
| 温度 (Temp)    | 0. 1                                                                                                                         |
| 令牌限制 (Limit) | 5                                                                                                                            |
| Top-K        | N/A                                                                                                                          |
| Top-P        | 1                                                                                                                            |
| 提示 (Prompt)  | 将电影评论分类为正面 (POSITIVE), 中性 (NEUTRAL) 或负面 (NEGATIVE).评论:“她”是一项令人不安的研究, 揭示了如果允许人工智能不受约束地持续进化, 人类将走向何方. 我希望有更多像这部杰作一样的电影.情绪: |
| 输出 (Output)  | POSITIVE                                                                                                                     |

### 4.2	单样本 & 少样本

在为 AI 模型创建提示时, **提供示例**很有帮助.
 
单样本提示提供单个示例, 因此得名单样本. 其思想是**模型有一个可以模仿以最好地完成任务的示例**. 少样本提示向模型提供**多个示例**. 这种方法向模型展示了它需要**遵循的模式**. 其思想类似于单样本, 但多个期望模式的示例**增加了模型遵循该模式的机会**.

| 字段    | 值                                                                                                                                                                                                                                                                                                                                                                                                           |
| ----- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 目标    | 将披萨订单解析为 JSON                                                                                                                                                                                                                                                                                                                                                                                               |
| 模型    | gemini-pro                                                                                                                                                                                                                                                                                                                                                                                                  |
| 温度    | 0.1                                                                                                                                                                                                                                                                                                                                                                                                         |
| 令牌限制  | 250                                                                                                                                                                                                                                                                                                                                                                                                         |
| Top-K | N/A                                                                                                                                                                                                                                                                                                                                                                                                         |
| Top-P | 1                                                                                                                                                                                                                                                                                                                                                                                                           |
| 提示    | 将顾客的披萨订单解析为有效的 JSON: **示例: **我想要一个小号披萨, 配料有奶酪、番茄酱和意大利辣香肠.  **JSON 响应：** json `{  "size": "small",  "type": "normal",  "ingredients": [["cheese", "tomato sauce", "peperoni"]] }`  **示例：** 我可以要一个大号披萨, 配料有番茄酱、罗勒和马苏里拉奶酪吗？ **JSON 响应：** Json `{  "size": "large",  "type": "normal",  "ingredients": [["tomato sauce", "bazel", "mozzarella"]] }`   现在, 我想要一个大号披萨, 一半是奶酪和马苏里拉奶酪. 另一半是番茄酱、火腿和菠萝.  **JSON 响应：** |
| 输出    | Json `{  "size": "large",  "type": "half-half",  "ingredients": [["cheese", "mozzarella"], ["tomato sauce", "ham", "pineapple"]] }`                                                                                                                                                                                                                                                                         |

### 4.3	系统, 上下文和角色提示

系统, 上下文和角色提示都是用于指导 LLM **如何生成文本**的技术, 但侧重点不同.

- **系统提示** (System prompting) 设置语言模型的**总体背景和目的**. 它定义了模型应该做什么的“**大局**”, 例如翻译语言, 分类评论等, 定义模型的基本能力和总体目标.
	
- **上下文提示** (Contextual prompting) 提供与当前对话或任务相关的**特定细节**或**背景信息**. 它帮助模型**理解所提问题的细微差别**, 并相应地调整响应, 提供实时的, 任务特定的信息以知道相应, 高度特定与当前任务或输入, 是动态的.
	
- **角色提示** (Role prompting) 为语言模型分配一个特定的**角色或身份**以供其采用. 这有助于模型**生成与所分配角色及其相关知识和行为一致的响应**, 用于构建模型的**输出风格和语调**, 增加了一层特异性和个性.

### 4.4	回退提示

回退是一种提高性能的技术, 它提示 LLM 首先考虑与手头特定任务相关的一个**更普遍的问题**, 然后将该普遍问题的答案输入到后续针对特定任务的提示中.

### 4.5	思维链

思维链提示是一种通过**生成中间推理步骤**来提高 LLM **推理能力**的技术, 思维链提示非常省力且有效, 可以获取可解释性, 似乎能在不同版本 LLM 切换时提高鲁棒性.

| 字段  | 值                                                                                                                                                                                                                                                                               |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 提示  | 当我 3 岁时, 我的伴侣是我年龄的 3 倍. 现在, 我 20 岁了. 我的伴侣多大了? **让我们一步一步地思考.**                                                                                                                                                                                                                   |
| 输出  | 1. 假设我的当前年龄是“x”岁. (注：原文此处有误，应基于问题信息) 2. 当我 3 岁时，我的年龄是 3 岁.   3. 那时我伴侣的年龄是我年龄的 3 倍，这意味着我伴侣的年龄是 3 * 3 = 9 岁.   4. 现在，我 20 岁了，这意味着自 我 3 岁以来，我的年龄增加了 20 - 3 = 17 岁.   5. 由于我 3 岁时伴侣的年龄是 9 岁，并且我的年龄增加了 17 岁，那么我伴侣的年龄也一定增加了 17 岁.   6. 因此，我伴侣当前的年龄是 9 + 17 = 26 岁.     所以，我的伴侣是 26 岁. |

### 4.6	自我一致性

是一种被主动设计和应用的, 旨在提升复杂问题解答准确性的策略性方法. 主要应用于**需要多步推理的问题**, 如数学问题, 逻辑谜题, 常识推理等.

核心思想是: 对于单一问题, 通过**引入多样性**并**寻求共识**, 来避免单次推理的随机错误, 从而得到可靠的答案.

自我一致性技术建立在两个关键洞察之上:

- **路径多样性**: 一个**复杂問題**通常可以通过多种不同的逻辑路径或思维方式得到正确答案. 然而, 模型在**一次**生成中可能因为微小的随机性而走上**错误的推理路径**.
	
- **共识即正确**: 尽管错误的路径可能各不相同, 但**正确的路径往往会趋向于同一个终点**(正确答案). 因此, 如果能从大量不同的推理过程中找到一个一致的答案, 那么这个答案的正确概率会远高于单次生成.

具体的步骤为:

- **生成多种推理路径**: 目标是让模型为同一个问题产生多个不同的**思考过程**, 设计一个包含链式推理的提示模板, 如 "让我们一步步思考", 对同一个问题执行多次采样;
	
- **答案的提取与聚合**: 编写一个简单的解析器, 从每条生成的文本中提取出最终答案, 生成一个答案集;
	
- **选择最一致的答案**: 选择出现次数最多的答案.


### 4.7	思维树

思维树(ToT)是一种先进的提示工程技术, 它引导大型语言模型像人类下棋一样进行思考. 它不再局限于生成单一的线性推理链条, 而是将问题解决过程构建成一棵“树”:在每个决策点, 模型会并行地探索多种可能的下一步(思维生成), 并像裁判一样评估每种方案的潜力和可行性(状态评估), 然后根据搜索算法(如深度优先搜索)选择最有希望的路径深入探索, 遇到死胡同时则回溯到上一个节点. 这种“探索-评估-规划”的机制, 使模型能够从全局视角系统性地解决复杂问题, 显著提升了其推理能力和决策质量.

### 4.8	ReAct (推理与行动)

推理与行动 Reason and Act 提示是一种范式, 让 AI 可以将自然语言推理和**外部搜索工具**相结合来解决复杂的问题.

## 5	代码提示

### 5.1	编写代码的提示

做好测试

### 5.2	解释代码的提示

没啥好说的

### 5.3	翻译代码的提示

也没啥好说的

### 5.4	调试和审查代码的提示

更没啥好说的

## 6	最佳实践

### 6.1	提供示例

在提示中提供 单样本 / 少样本 的示例

### 6.2	简洁设计

提示简洁, 清晰, 易于理解

### 6.3	具体说明输出

不要假设模型知道你想要什么, 明确说明约束 (如长度, 内容焦点和风格)

### 6.4	使用指令而非约束

- 指令提供的是关于响应的期望格式, 风格或内容的明确指示, 指导模型应该产出什么;
	
- 约束是限制, 限制模型不要做什么.


如: 

查询最出名的五篇 Java 文章, 仅讨论 xxx.

查询最出名的五篇 Java 文章, 不要列出 xxx.

### 6.5	控制最大令牌长度

可配置, 可在指令中明确指出, 如: 用一条推文的长度解释量子物理学.

### 6.6	在提示中使用变量

没啥好说

### 6.7	尝试不同的输入风格和写作风格

### 6.8	对于带分类的少样本提示, 混合类别





---

# 💭 我的思考

这个观点如何与我已知的知识产生联系? 它让我想到了什么?