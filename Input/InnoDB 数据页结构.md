---
source:
type: input
---
# 📰 阅读笔记

![[InnoDB 的数据页结构.png|350]]

## 1	记录在页中的存储

记录存储在页的 User Records 部分, 每插入一条记录, MySQL 将 Free Space 的一部分划分到 User Records; Free Space 耗尽, 则说明这个页没有空间了.

记录头信息在 "记录在页中的存储" 这个主题中非常重要.

![[InnoDB Compact 行记录格式.png]]

### 1.1	delete_mask

占用 1bit, 标记当前记录是否被删除.

MySQL 中被删除的记录不会立即从磁盘上移除, 而是会打上一个空闲标记, 并将其维护在一个垃圾链表中, 作为可重用空间.

### 1.2	min_rec_mask

占用 1bit, 标记 B+ 树每层非叶子节点的最小记录.

### 1.3	heap_no

占用 13bit, 标识当前记录在记录堆中的位置信息.

向页面中插入 2 条记录, heap_no 会为 2, 3, 而编号为 0 和 1 的两条记录是代表最大记录和最小记录的伪记录, 存储在 infimum, supremum 区域.

这两个记录作为链表头和链表尾存在, 

### 1.4	record_type

占用 3bit, 表示当前记录的类型,  0 表示普通记录, 1 表示 B+ 树非叶节点记录, 2 表示最小记录, 3 表示最大记录. 用户插入的记录就是普通记录, 它们的 record_type 值都是 0, 而最小记录和最大记录的 record_type 值分别为 2 和 3.

### 1.5	next_record

占用 16bit, 它表示从当前记录的真实数据到下一条记录的**真实数据**的地址偏移量.

没有指向下一条记录的起始位置, 而是指向了对象头与真实数据之间的位, 离对象头和真实数据都比较近, 读取方便.

## 2	Page Dictionary

是对页内数据的索引, 它的制作过程如下:

- 分组:将所有正常的记录 (包括最大和最小记录, 不包括已删除记录) 划分为若干个组.
	
- 每个组的最后一条记录(组内最大记录)的头信息中, n_owned 属性存储该组内记录的数量.
	
- 将每个组的最后一条记录的地址偏移量按顺序提取出来. 这些偏移量存储在靠近页尾部的区域, 称为页目录, 页目录中的每个偏移量称为槽(Slot).

最小记录所在的分组只能有 1 条记录, 最大记录所在的分组拥有的记录条数只能在 1~8 条之间, 剩下的分组中记录的条数范围只能在是 4~8 条之间.

分组是按照下边的步骤进行的:

- 初始情况下一个数据页里只有最小记录和最大记录两条记录, 它们分属于两个分组.
	
- 之后每插入一条记录, 都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽, 然后把该槽对应的记录的 n_owned 值加 1, 表示本组内又添加了一条记录, 直到该组中的记录数等于 8 个.
	
- 在一个组中的记录数等于 8 个后再插入一条记录时, 会将组中的记录拆分成两个组, 一个组中 4 条记录, 另一个 5 条记录. 这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量.

真实查找时通过二分法确定该记录所在的槽, 并找到该槽所在分组中主键值最小的那条记录, 然后通过记录的 next_record 属性遍历该槽所在的组中的各个记录.

## 3	Page Header

占用 56 字节, 用于存储页的状态信息.

|         名称          | 占用空间大小 |                                 描述                                  |
| :-----------------: | :----: | :-----------------------------------------------------------------: |
| PAGE_N_DIR_SLOTS  |  2 字节  |                              在页目录中的槽数量                              |
|   PAGE_HEAP_TOP   | 2 字节  |                还未使用的空间最小地址, 也就是说从该地址之后就是 Free Space                 |
|    PAGE_N_HEAP   | 2 字节  |                   本页中的记录的数量, 包括最小和最大记录以及标记为删除的记录                    |
|     PAGE_FREE     | 2 字节  | 第一个已经标记为删除的记录地址, 各个已删除的记录通过 next_record 也会组成一个单链表, 这个单链表中的记录可以被重新利用 |
|  PAGE_GARBAGE    | 2 字节  |                             已删除记录占用的字节数                             |
| PAGE_LAST_INSERT  | 2 字节  |                              最后插入记录的位置                              |
|  PAGE_DIRECTION   | 2 字节  |                               记录插入的方向                               |
| PAGE_N_DIRECTION  | 2 字节  |                            一个方向连续插入的记录数量                            |
|    PAGE_N_RECS   | 2 字节  |                   该页中记录的数量, 不包括最小和最大记录以及被标记为删除的记录                   |
|  PAGE_MAX_TRX_ID  | 8 字节  |                      修改当前页的最大事务ID, 该值仅在二级索引中定义                      |
|    PAGE_LEVEL     | 2 字节  |                           当前页在 B+ 树中所处的层级                           |
|   PAGE_INDEX_ID   | 8 字节  |                         索引 ID, 表示当前页属于哪个索引                          |
| PAGE_BTR_SEG_LEAF | 10 字节 |                   B+ 树叶子段的头部信息, 仅在 B+ 树的 Root 页定义                   |
| PAGE_BTR_SEG_TOP  | 10 字节 |                  B+ 树非叶子段的头部信息, 仅在 B+ 树的 Root 页定义                   |

### 3.1	PAGE_DIRECTION 与 PAGE_N_DIRECTION

#### 3.1.1	PAGE_DIRECTION

PAGE_DIRECTION 记录上一次插入是朝着页的哪个“方向”进行的, 它主要可以有以下几种状态(或方向):

- LEFT: 表示上一次插入的新记录的主键值小于当前页中已有的最小记录. 这通常意味着插入发生在页的“开头”部分. 在实践中, 这种情况比较少见.
	
- RIGHT: 表示上一次插入的新记录的主键值大于当前页中已有的最大记录. 这通常意味着插入发生在页的“末尾”部分. 这是顺序插入的典型特征.
	
- 未知 / 无方向: 如果上一次插入发生在页的中间, 或者这是页的第一次插入, 那么方向可能被设置为一个表示“未知”或“无”的值.

PAGE_DIRECTION 可以用于优化插入, 当需要插入新记录时, InnoDB 会查看 PAGE_DIRECTION 字段.

- 如果 PAGE_DIRECTION 是 RIGHT, 并且**这次要插入的新记录的主键值大于上一次插入的记录的主键值**, 那么 InnoDB 可以确信这次插入仍然是顺序的. 因此, 它可以直接从页的末尾开始寻找插入位置, 无需从页的开头开始遍历.
	
- 如果方向是 LEFT 并且**新记录的主键更小**, 它可以从页的开头开始查找.

这种“预测”避免了从链表头部开始进行耗时的线性扫描, 实现了近似 O(1) 的插入复杂度, 而不是 O(n).

#### 3.1.2	PAGE_N_DIRECTION

用于记录连续朝同一个方向插入记录的次数.

计数器提供插入模式的“强度”或“稳定性” 信息.

- 计数越大, 说明顺序插入的模式越稳定, 越可信. InnoDB 可以更有信心地应用优化, 直接从上次插入点之后开始搜索.
	
- 计数很小(比如只有 1 或 2), 说明顺序插入的模式可能只是偶然, 或者刚刚开始. 引擎可能会采取相对保守的查找策略.
	
- 当插入方向改变或模式被打破时, 计数器会被重置. 这相当于系统“忘记”了旧的不稳定的模式, 准备学习新的模式.

## 4	File Header

|                 名称                 | 占用空间大小 |                描述                 |
| :--------------------------------: | :----: | :-------------------------------: |
|     `FIL_PAGE_SPACE_OR_CHKSUM`     | `4`字节  |               页的校验和               |
|         `FIL_PAGE_OFFSET`          | `4`字节  |                页号                 |
|          `FIL_PAGE_PREV`           | `4`字节  |              上一个页的页号              |
|          `FIL_PAGE_NEXT`           | `4`字节  |              下一个页的页号              |
|           `FIL_PAGE_LSN`           | `8`字节  |         页面被最后修改时对应的日志序列位置         |
|          `FIL_PAGE_TYPE`           | `2`字节  |               该页的类型               |
|     `FIL_PAGE_FILE_FLUSH_LSN`      | `8`字节  | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` | `4`字节  |             页属于哪个表空间              |

数据页类型

|           类型名称            |  十六进制  |         描述         |
| :-----------------------: | :----: | :----------------: |
| `FIL_PAGE_TYPE_ALLOCATED` | 0x0000 |     最新分配, 还没使用     |
|    `FIL_PAGE_UNDO_LOG`    | 0x0002 |      Undo 日志页      |
|     `FIL_PAGE_INODE`      | 0x0003 |       段信息节点        |
| `FIL_PAGE_IBUF_FREE_LIST` | 0x0004 | Insert Buffer 空闲列表 |
|  `FIL_PAGE_IBUF_BITMAP`   | 0x0005 |  Insert Buffer 位图  |
|    `FIL_PAGE_TYPE_SYS`    | 0x0006 |        系统页         |
|  `FIL_PAGE_TYPE_TRX_SYS`  | 0x0007 |       事务系统数据       |
|  `FIL_PAGE_TYPE_FSP_HDR`  | 0x0008 |      表空间头部信息       |
|   `FIL_PAGE_TYPE_XDES`    | 0x0009 |       扩展描述页        |
|   `FIL_PAGE_TYPE_BLOB`    | 0x000A |        溢出页         |
|     `FIL_PAGE_INDEX`      | 0x45BF | 索引页，也就是我们所说的`数据页`  |

## 5	File Tailer

存储页的校验和与页面被最后修改时对应的日志序列位置 (LSN)

这个部分是和 File Header 中的校验和相对应的. 每当一个页面在内存中修改了, 在同步之前就要把它的校验和算出来, 因为 File Header 在页面的前边, 所以校验和会被首先同步到磁盘, 当完全写完时, 校验和也会被写到页的尾部, 如果完全同步成功, 则页的首部和尾部的校验和应该是一致的. 如果写了一半儿断电了, 那么在 File Header 中的校验和就代表着已经修改过的页, 而在 File Trailer 中的校验和代表着原先的页, 二者不同则意味着同步中间出了错.

---

# 💭 我的思考

这个观点如何与我已知的知识产生联系? 它让我想到了什么?