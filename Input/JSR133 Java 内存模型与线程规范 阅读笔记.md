---
source: https://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%88.pdf
type: input
banner: Assets/Banner/pexels-walidphotoz-1509582.jpg
---
# 📰 阅读笔记

## 1	介绍

JVM 支持多线程执行, 线程是用 Thread 类表示的, 用户创建线程的**唯一方式**是创建一个 Thread 类的对象, 每个线程都与这样的一个对象相关联.

JSR133 描述了用 Java 语言编写的**多线程程序**的**语义**. 包括多线程更新共享变量时, 读操作能看到什么值的规则.

### 1.1	锁

有多种机制可以用于[[Java 中的线程间通信|线程间通信]], 其中最基础的是同步, 同步是用管程 (monitor) 来实现的.

**每个对象**都关联着一个管程, 线程可以用它来执行 lock 或 unlock 操作, 每次仅有一个线程可以持有管程上的锁.

线程 t 可以锁定一个管程多次, 每次 unlock 都会将一次 lock 撤销, 是**可重入**的.

[[Java Synchronized 关键字实现原理|synchronized]] 需要一个对象的引用, 随后会尝试在该对象的远程上执行 lock 动作, 如果 执行失败就会一直等待, 不管是代码快还是方法, 在结束时都会自动执行 unlock.

## 2	未正确同步的程序会表现出出人意料的行为

```java
// Thread1
1: r2 = A;
2: B = 1;

// Thread2
3: r1 = B;
4: A = 2;
```

最终可能表现出来 r2 = 2, r1 = 1 的情况, 因为经过重排序后语句的执行顺序可能为 4, 1, 2, 3.

这是由于, 上面的代码没有被充分同步:

- 一个线程中有一个写操作;
	
- 另一个线程中读取了写入的变量值;
	
- 读写操作未被同步排序.

上述情况被称为 **数据争用 data rece**.

产生重排序的原因:

- JIT 编译器和处理器可以对代码进行重新整理;
	
- JVM 的机器的分级存储系统可以使代码看起来像被重排序过.

## 3	非正式语义

正确的同步不能保证所有的行为都是正确的; 程序必须正确同步, 以避免代码被重排序后能看到那些有违直觉的行为. 使用了正确的同步并**不能确保**程序的**所有行为**都是正确的. 但是, 正确的同步确实可以让编码人员用简单的方式**推断程序可能的行为**; 正确同步的程序的行为对可能的重排序**依赖性更低**. 缺乏正确同步, 就可能出现十分诡异, 让人费解和有违直觉的行为.

理解程序同步的两个关键概念:

- 冲突访问: 对同一个共享字段或数组元素存在两个访问, 但至少有一个访问是写操作, 就称作有冲突.
	
- Happens Before 关系: 两个动作可以被 Happens-Before 关系排序, 如果一个动作 Happens-Before 另一个动作, 则第一个动作对内存的改变对第二个动作是可见的. Happens-Before 规则保证的可见性, 而不是执行顺序, 如果更换顺序对可见性没有硬性, 编译器和处理器可以对指令进行重排序.

### 3.1	顺序一致性

顺序一致性是程序员理想中 "全序且立即可见" 的完美模型, 但现代硬件为了性能(通过缓存和重排序)打破了这种一致性; 

Java 内存模型对此提供了一个核心承诺: 只要程序员通过正确同步消除了数据争用, JMM 就会屏蔽底层的复杂优化, 保证程序的执行结果 "看起来" 完全符合顺序一致性模型, 这让你无需纠结底层的乱序细节就能用直觉推断代码行为, 但仍需注意复合操作(如 i++)本身的原子性逻辑.

### 3.2	final 字段

final 关键字赋予了 "初始化安全性": 只要遵循 "在构造函数完成前不让对象引用(this)逃逸" 这一原则, Java 内存模型(JMM)就强制保证, 任何线程一旦看到了这个对象, 就一定能看到其 final 字段被正确初始化后的值, 而无需任何额外的同步措施. 

这意味着可以利用 final 轻松构建高效且线程安全的不可变对象, 并享受编译器激进优化(如缓存值到寄存器)带来的性能红利, 但同时必须警惕: **如果字段不是 final 的, 即使对象引用可见, 其他线程仍可能读到该字段未初始化时的默认值 (如 0 或 null).**

## 4	什么是内存模型?

给定一个程序和该程序的一串执行轨迹, 内存模型描述了该轨迹是否是该程序的一次**合法执行**. 对于 Java, 内存模型**检查执行中的每次读操作**, 然后根据特定规则, 校验该读操作观察到的写是否合法.

## 5	定义

### 5.1	共享变量与堆内存

能够在线程间共享的内存称为共享内存或堆内存, 方法的局部变量不会在这里.

### 5.2	线程间动作

由某一线程执行, 能被另一个线程探测或直接影响的动作, 包括

- 共享变量的读写
	
- 同步动作
	
- 读写某个 volatile 变量
	
- 启动一个线程
	
- 外部动作, 线程发散动作



---

# 💭 我的思考

这个观点如何与我已知的知识产生联系? 它让我想到了什么?